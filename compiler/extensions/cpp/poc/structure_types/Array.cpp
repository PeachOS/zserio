/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#include <zserio/Arrays.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include "Array.h"

Array::Array() noexcept
:   m_isInitialized(false)
{
}

Array::Array(zserio::BitStreamReader& in,
        uint32_t _size) :
        m_size_(_size),
        m_isInitialized(true)
{
    read(in);
}

// MBition: Make this a default copy, nothing special is happening here, call to initialize only copies values as well
Array::Array(const Array& other) :
        m_values_(other.m_values_)
{
    if (other.m_isInitialized)
        initialize(other.m_size_);
    else
        m_isInitialized = false;
}
// MBition: same as in copy ctor
Array& Array::operator=(const Array& other)
{
    m_values_ = other.m_values_;
    if (other.m_isInitialized)
        initialize(other.m_size_);
    else
        m_isInitialized = false;

    return *this;
}

// MBition: Remove function in favour of defaulted copy ctor
void Array::initialize(
        uint32_t _size)
{
    m_size_ = _size;
    m_isInitialized = true;
}

// MBition: Definitely not noexcept! There is a throw..
uint32_t Array::getSize() const noexcept
{
    if (!m_isInitialized)
        throw zserio::CppRuntimeException("Parameter size of compound Array "
                "is not initialized!");

    return m_size_;
}

std::vector<int32_t>& Array::getValues() noexcept
{
    return m_values_;
}

const std::vector<int32_t>& Array::getValues() const noexcept
{
    return m_values_;
}

void Array::setValues(const std::vector<int32_t>& _values)
{
    m_values_ = _values;
}

void Array::setValues(std::vector<int32_t>&& _values)
{
    m_values_ = std::move(_values);
}

void Array::setValues(std::initializer_list<int32_t> _values)
{
    m_values_ = _values;
}

size_t Array::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += zserio::bitSizeOf<zserio::StdIntArrayTraits<int32_t>>(m_values_, endBitPosition);

    return endBitPosition - bitPosition;
}

// MBition: This can be reduced to one line aka "return zserio::initializeOffsets<zserio::StdIntArrayTraits<int32_t>>(m_values_, bitPosition);"
size_t Array::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = zserio::initializeOffsets<zserio::StdIntArrayTraits<int32_t>>(m_values_, endBitPosition);

    return endBitPosition;
}

bool Array::operator==(const Array& other) const
{
    if (this != &other)
    {
        return
                (getSize() == other.getSize()) &&
                (m_values_ == other.m_values_);
    }

    return true;
}

int Array::hashCode() const
{
    int result = zserio::HASH_SEED;

    result = zserio::calcHashCode(result, getSize());
    result = zserio::calcHashCode(result, m_values_);

    return result;
}

void Array::read(zserio::BitStreamReader& in)
{
    zserio::read<zserio::StdIntArrayTraits<int32_t>>(m_values_, in, static_cast<size_t>(getSize()));
}

void Array::write(zserio::BitStreamWriter& out, zserio::PreWriteAction)
{
    if (m_values_.size() != static_cast<size_t>(getSize()))
    {
        throw zserio::CppRuntimeException("Write: Wrong array length for field Array.values: " +
                zserio::convertToString(m_values_.size()) + " != " +
                zserio::convertToString(static_cast<size_t>(getSize())) + "!");
    }
    zserio::write<zserio::StdIntArrayTraits<int32_t>>(m_values_, out);
}
