/**
 * Automatically generated by Zserio C++ extension version 1.2.0.
 */

#ifndef STRUCTURE_H
#define STRUCTURE_H

#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/PreWriteAction.h>
#include <zserio/OptionalHolder.h>
#include <zserio/Types.h>

#include "Array.h"
#include "String.h"


class Structure;

// force zserio::OptionalHolder<Structure> to strore value on heap because Structure is recursive
namespace zserio
{
namespace detail
{
    template <>
    struct is_optimized_in_place<Structure>
    {
        static const bool value = false;
    };
}
}

class Structure
{
public:
    Structure() noexcept;
    explicit Structure(zserio::BitStreamReader& in);

    // new in cpp11
    // not that ZSERIO prefix (case-insensitive) will be disabled by compiler for all user-defined identifiers
    template <typename ZSERIO_T_array, typename ZSERIO_T_extraArray, typename ZSERIO_T_str,
                typename ZSERIO_T_recursive>
    explicit Structure(uint32_t _size, ZSERIO_T_array&& _array, bool _hasExtra,
            const zserio::OptionalHolder<uint32_t>& _extraSize, ZSERIO_T_extraArray&& _extraArray,
            ZSERIO_T_str&& _str, ZSERIO_T_recursive&& _recursive)
    :   m_areChildrenInitialized(true), m_size(_size), m_array(std::forward<ZSERIO_T_array>(_array)),
        m_hasExtra(_hasExtra), m_extraSize(_extraSize),
        m_extraArray(std::forward<ZSERIO_T_extraArray>(_extraArray)),
        m_str(std::forward<ZSERIO_T_str>(_str)), m_recursive(std::forward<ZSERIO_T_recursive>(_recursive))
    {
    }

    // MBition: With a C++11 inmplementation of std::optional and std::any all those ctors should be defaulted as no custom copy/move code is required
    // TODO: is default really ok? see copy ctor! // TODO: NO, when children compound is in place!!! IMPLEMENT!
    Structure(Structure&&);
    Structure& operator=(Structure&& other);

    Structure(const Structure& other);
    Structure& operator=(const Structure& other);

    void initializeChildren();

    uint32_t getSize() const noexcept;
    void setSize(uint32_t _size);

    Array& getArray() noexcept;
    const Array& getArray() const noexcept;
    void setArray(const Array& _array);
    void setArray(Array&& _array);

    bool getHasExtra() const noexcept;
    void setHasExtra(bool _hasExtra);

    zserio::OptionalHolder<uint32_t>& getExtraSize() noexcept;
    const zserio::OptionalHolder<uint32_t>& getExtraSize() const noexcept;
    void setExtraSize(const zserio::OptionalHolder<uint32_t>& _extraSize);
    bool hasExtraSize() const; // TODO: can be noexcept??? what if the expression cause an exception?

    zserio::OptionalHolder<Array>& getExtraArray() noexcept;
    const zserio::OptionalHolder<Array>& getExtraArray() const noexcept;
    void setExtraArray(const zserio::OptionalHolder<Array>& _extraArray);
    void setExtraArray(zserio::OptionalHolder<Array>&& _extraArray);
    bool hasExtraArray() const;

    String& getStr() noexcept;
    const String& getStr() const noexcept;
    void setStr(const String& _str);
    void setStr(String&& _str);

    zserio::OptionalHolder<Structure>& getRecursive() noexcept;
    const zserio::OptionalHolder<Structure>& getRecursive() const noexcept;
    void setRecursive(const zserio::OptionalHolder<Structure>& _recursive);
    void setRecursive(zserio::OptionalHolder<Structure>&& _recursive);
    bool hasRecursive() const;

    size_t bitSizeOf(size_t bitPosition = 0) const; // TODO: can be noexcept?
    size_t initializeOffsets(size_t bitPosition);

    bool operator==(const Structure& other) const;
    int hashCode() const; // TODO: can be noexcept?

    void read(zserio::BitStreamReader& in);
    void write(zserio::BitStreamWriter& out,
            zserio::PreWriteAction preWriteAction = zserio::ALL_PRE_WRITE_ACTIONS);

private:
    bool m_areChildrenInitialized;
    uint32_t m_size;
    Array m_array;
    bool m_hasExtra;
    zserio::OptionalHolder<uint32_t> m_extraSize;
    zserio::OptionalHolder<Array> m_extraArray;
    String m_str;
    zserio::OptionalHolder<Structure> m_recursive;
};

#endif // STRUCTURE_H
